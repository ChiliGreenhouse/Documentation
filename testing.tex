\section{Testplanung}
Außerhalb von Modultests, welche in allen drei Komponenten durchgeführt wurden, wurden und Systemtests durchgeführt, auf welche sich in diesem Abschnitt fokussiert wird.
Da alle Interaktionen der Hardware oder des Frontends über die API gehen müssen, steht diese bei der Planung und Betrachtung von Tests im Mittelpuntkt.
Zuerst wird ein Überblick gegeben, wie die Tests geschrieben werden und im Anschluss wird etwas näher auf die Testplanung eingegangen.

Die Tests werden im Stil von Akzeptanztests aus Behavior Driven Development in der Sprache Gherkin verfasst.
Dies hat den Grund, dass sich die Tests so einfacher formulieren und verstehen lassen.
Da sich diese Tests auch ausführen lassen, sofern alle Schritte implementiert sind, geht man hier in die Richtung einer ausführbaren Spezifikation.

Um das Verhalten der API leichter zu testen, wurde eine virtuelle Python Umgebung geschrieben, welche ein Greenhouse simuliert.
Diese Umgebung kann direkt aus den Tests genutzt werden, um der API Daten zu schicken und die Antworten dieser zu verifizieren.

Im folgenden wird die Planung der Tests und Bildung der Äquivalenzklassen beispielhaft an der API vorgestellt.

\subsection{Registrieren von Geräten}
Wenn ein neuer Sensor oder ein neuer Aktor zu einem Greenhouse hinzugefügt wird, soll dies auch der API mitgeteilt werden.
Hierfür gibt es einen Endpunkt mit dem man ein Gerät unter einem bestimmten Namen registrieren kann.
Dabei ergeben sich nur zwei Äquivalenzklassen, nämlich dass bereits ein Gerät mit diesem Namen existiert (GE im folgenden), oder dass ein Gerät mit diesem Name eben noch nicht existiert (GNE im Folgenden):

\begin{center}
\small
\begin{tabular}{|c||c|c|}
\hline
Äquivalenzklasse&GE&GNE \\
\hline
Gültigkeit&Nicht Gültig&Gültig \\
\hline
Erwarteter Wert&HTTP 409&HTTP 201 \\
\hline
\end{tabular}
\end{center}

Eine Implementierung des Verhaltens der Klasse GE in der Sprache Gherkin könnte folgendermaßen aussehen
\begin{figure}[H]
    \begin{minted}[linenos]{gherkin}
Scenario: Creating a device with a name that already exists    
    Given a device with name soil_moisture exists
    When I try to create a device with the name soil_moisture
    Then the API should emit a negative response with HTTP code 409
    \end{minted}
    \label{lst:test_create}
    \caption{Beispielhafte Testimplementierung in Gherkin}
\end{figure}

\subsection{Senden von Datenpunkten}
Da sich im letzten Beispiel nur zwei Äquivalenzklassen ergaben, welche sich nicht kombinieren lassen, wird im Folgenden ein etwas komplizierteres Beispiel betrachtet.
Beim Senden von Datenpunkten muss wieder der Name eines Geräts angegeben werden, jedoch muss überprüft werden ob das Gerät vom Typ Sensor ist, da nur diese Datenpunkte senden dürfen. 

Hierbei ergeben sich folgende Äquivalenzklassen: Ein Gerät mit dem Namen existiert (GE), Ein Gerät mit dem Namen existiert nicht (GNE), Das Gerät ist vom Typ Sensor (TS), Das Gerät ist nicht vom Typ Sensor (NTS).
Diese Äquivalenzklassen lassen sich nun auf folgende Weisen kombinieren:

\begin{center}
    \begin{tabular}{c||c|c}
        &TS&NTS\\
        \hline
        \hline
        GE&GE+TS&GE+NTS\\
        \hline
        GNE& \multicolumn{2}{c}{GNE}\\
    \end{tabular}
\end{center}

Die unteren Beiden kombinierten Einträge können zu einem Eintrag zusammengefasst werden, da die Überprüfung nach Existenz wichtiger ist als nach richtigem Typ.
Falls kein Gerät mit diesem Namen existiert, ist die Information, ob es vom richtigen Typ ist, überflüssig.

Für die zusammengesetzten Äquivalenzklassen kann man nun die Gültigkeit und die erwarteten Werte erfassen:

\begin{center}
    \begin{tabular}{|c||c|c|c|}
        \hline
        Äquivalenzklasse&GE+TS&GE+NTS&GNE\\
        \hline
        Gültigkeit&Gültig&Nicht Gültig&Nicht Gültig\\
        \hline
        Erwarteter Wert&HTTP 200&HTTP 422&HTTP 409\\
        \hline
    \end{tabular}
\end{center}

Eine mögliche Implementierung eines Tests zur Äquivalenzklasse GE+NTS könnte folgendermaßen aussehen:

\begin{figure}[H]
    \begin{minted}[linenos]{gherkin}
Scenario: A device of type actuator tries to record a datapoint
    Given a device lamp exists
    And the device lamp is of type actuator
    When the device tries to record a datapoint
    Then the API should emit a negative response with HTTP code 422
    \end{minted}
\end{figure}

Die Schritte aus diesem Test sind per Parametrisierung wiederverwendbar gestaltet um in den Tests für die anderen Äquivalenzklassen erneut benutzt werden zu können.